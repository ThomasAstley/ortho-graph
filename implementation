# Graph description

we compute N and E from G
N = { A, B, C, D }
E = { AB, BC, CD }

G = 
	{ 
	A -> B,
	B -> C,
	C -> D 
	}

# Routing Algorithm

- read graph description
- transform to get list of nodes and edges
- assign position to each node
- calculate edges 

# Implementation Ideas

Min change of direction:
map
record direction when adding nodes to frontier (0,1,2,3) with 0 being north, 1 east, 2 south, 3 west
compare that value to value given to parent node
Either assign default value of -1 to origin node and skip this step for first iteration, or assign a preferred starting direction
for a text description of the route taken, store the parent node as a corner in the route (maybe with new corner value that is boolean with origin and destination also set to true) and then a straight line description can be obtained from this information

e.g. We have origin of (1,1), destination at (25,5) and corner at (25,1)
O-----------------------*
                        |
                        |
                        |
                        D

The corner would have a direction of 1 when added to the frontier, so we would describe this as east. Then we can compare this nodes coordinates to the previous corners coordinates to obtain distance moved in that direction. So, the corner would have distance of abs(25-1) + abs(1-1) = 24
Overall the path could be written in the form TBD [24E,4S], [[24,E],[4,S]], [24.E,4.S], [[24,1],[4,2]], [24.1,4.2] (whichever is easiest to interpret by a user and also easy to implement into code)


